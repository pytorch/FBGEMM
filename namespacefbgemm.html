<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fbgemm_gpu: fbgemm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fbgemm_gpu
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fbgemm Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1_b_c_s_r_matrix.html">BCSRMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1block__type__t.html">block_type_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1_blocking_factors.html">BlockingFactors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_code_cache.html">CodeCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_code_gen_base.html">CodeGenBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_compressed_sparse_column.html">CompressedSparseColumn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_do_nothing.html">DoNothing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_do_s_conv_on_inp_buffer.html">DoSConvOnInpBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_do_spmdm_on_inp_buffer.html">DoSpmdmOnInpBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_execute_kernel.html">ExecuteKernel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_execute_kernel_3_01packing_a_matrix_00_01_pack_b_matrix_3_01int8__t_00_01typenam9894617fba2431fcc8042b1a22b96270.html">ExecuteKernel&lt; packingAMatrix, PackBMatrix&lt; int8_t, typename packingAMatrix::accType &gt;, cT, processOutputType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1is__8bit.html">is_8bit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1mem_copy.html">memCopy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_pack_a_matrix.html">PackAMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_pack_a_with_im2_col.html">PackAWithIm2Col</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_pack_a_with_quant_row_offset.html">PackAWithQuantRowOffset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_pack_a_with_row_offset.html">PackAWithRowOffset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_pack_b_matrix.html">PackBMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_packed_gemm_matrix_b.html">PackedGemmMatrixB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1_packing_traits.html">PackingTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_pack_matrix.html">PackMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_pack_weight_matrix_for_g_conv.html">PackWeightMatrixForGConv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_pack_weights_for_conv.html">PackWeightsForConv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_relu_output.html">ReluOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1requantization_for_float_params__t.html">requantizationForFloatParams_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1_requantization_params.html">RequantizationParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1requantization_params__t.html">requantizationParams_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_re_quantize_for_float.html">ReQuantizeForFloat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_re_quantize_output.html">ReQuantizeOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_scale_o_p.html">ScaleOP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbgemm_1_1_sparse_ada_grad_signature.html">SparseAdaGradSignature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1_tensor_quantization_params.html">TensorQuantizationParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbgemm_1_1thread__type__t.html">thread_type_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5356ce4b0771923d6eee8b3692afd2f3" id="r_a5356ce4b0771923d6eee8b3692afd2f3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5356ce4b0771923d6eee8b3692afd2f3">impl_type_t</a> </td></tr>
<tr class="separator:a5356ce4b0771923d6eee8b3692afd2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1f01b8b3f8fea3e9c8ccc2aed30ba70a" id="r_a1f01b8b3f8fea3e9c8ccc2aed30ba70a"><td class="memTemplParams" colspan="2">template&lt;typename packingAMatrix , typename packingBMatrix , typename cT , typename processOutputType &gt; </td></tr>
<tr class="memitem:a1f01b8b3f8fea3e9c8ccc2aed30ba70a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f01b8b3f8fea3e9c8ccc2aed30ba70a">fbgemmPacked</a> (<a class="el" href="classfbgemm_1_1_pack_matrix.html">PackMatrix</a>&lt; packingAMatrix, typename packingAMatrix::inpType, typename packingAMatrix::accType &gt; &amp;packA, <a class="el" href="classfbgemm_1_1_pack_matrix.html">PackMatrix</a>&lt; packingBMatrix, typename packingBMatrix::inpType, typename packingBMatrix::accType &gt; &amp;packB, cT *C, std::int32_t *C_buffer, std::uint32_t ldc, const processOutputType &amp;outProcess, int thread_id, int num_threads, const <a class="el" href="structfbgemm_1_1_blocking_factors.html">BlockingFactors</a> *blocking_params=nullptr)</td></tr>
<tr class="separator:a1f01b8b3f8fea3e9c8ccc2aed30ba70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5780ef4a16a1682740af29283360caa4" id="r_a5780ef4a16a1682740af29283360caa4"><td class="memTemplParams" colspan="2">template&lt;typename packed_W , typename outType , bool FUSE_RELU, QuantizationGranularity Q_GRAN, int SPATIAL_DIM = 2, typename BIAS_TYPE  = std::int32_t&gt; </td></tr>
<tr class="memitem:a5780ef4a16a1682740af29283360caa4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5780ef4a16a1682740af29283360caa4">fbgemmGroupwiseConv</a> (const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; SPATIAL_DIM &gt; &amp;conv_param, const std::uint8_t *activations, std::int32_t a_zero_point, std::int32_t *rowOffsetBuf, packed_W &amp;packed_weights, outType *out, std::int32_t *outBuffer, const <a class="el" href="classfbgemm_1_1_re_quantize_output.html">ReQuantizeOutput</a>&lt; FUSE_RELU, Q_GRAN, BIAS_TYPE &gt; &amp;outProcess, int thread_id, int num_threads)</td></tr>
<tr class="separator:a5780ef4a16a1682740af29283360caa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f972dca3254066120f58af5cf3b304c" id="r_a8f972dca3254066120f58af5cf3b304c"><td class="memTemplParams" colspan="2">template&lt;int SPATIAL_DIM = 2&gt; </td></tr>
<tr class="memitem:a8f972dca3254066120f58af5cf3b304c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f972dca3254066120f58af5cf3b304c">rowOffsetBufferSizeGConv</a> (const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; SPATIAL_DIM &gt; &amp;conv_param)</td></tr>
<tr class="separator:a8f972dca3254066120f58af5cf3b304c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9d2af7ea01634fd2e5bef0e6baa0ab" id="r_adc9d2af7ea01634fd2e5bef0e6baa0ab"><td class="memTemplParams" colspan="2">template&lt;typename processOutputType , int SPATIAL_DIM = 2, typename ACC_T  = std::int32_t&gt; </td></tr>
<tr class="memitem:adc9d2af7ea01634fd2e5bef0e6baa0ab"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc9d2af7ea01634fd2e5bef0e6baa0ab">fbgemmConv</a> (const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; SPATIAL_DIM &gt; &amp;conv_p, const std::uint8_t *activations, <a class="el" href="classfbgemm_1_1_pack_weights_for_conv.html">PackWeightsForConv</a>&lt; SPATIAL_DIM, std::int8_t, ACC_T &gt; &amp;packed_weights, typename processOutputType::outType *out, std::int32_t *outBuffer, processOutputType &amp;outProcess, int thread_id, int num_threads, const <a class="el" href="structfbgemm_1_1_blocking_factors.html">BlockingFactors</a> *blocking_params=nullptr)</td></tr>
<tr class="separator:adc9d2af7ea01634fd2e5bef0e6baa0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bda89769bca9a01ddf81591f20ef02" id="r_ad5bda89769bca9a01ddf81591f20ef02"><td class="memTemplParams" colspan="2">template&lt;int SPATIAL_DIM = 2, typename ACC_T  = std::int32_t&gt; </td></tr>
<tr class="memitem:ad5bda89769bca9a01ddf81591f20ef02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ae779e18e5742efa69f340bcb616acdb2">optimized_conv_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5bda89769bca9a01ddf81591f20ef02">ConvFastPath</a> (const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; SPATIAL_DIM &gt; &amp;conv_p)</td></tr>
<tr class="separator:ad5bda89769bca9a01ddf81591f20ef02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f5d961c6a42aab1c37b17a3d93770" id="r_ab22f5d961c6a42aab1c37b17a3d93770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab22f5d961c6a42aab1c37b17a3d93770">FloatToBfloat16_ref</a> (const float *src, bfloat16 *dst, size_t size)</td></tr>
<tr class="separator:ab22f5d961c6a42aab1c37b17a3d93770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84f2b20490beb1dd0da4b03cf93afac" id="r_af84f2b20490beb1dd0da4b03cf93afac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84f2b20490beb1dd0da4b03cf93afac">Bfloat16ToFloat_ref</a> (const bfloat16 *src, float *dst, size_t size)</td></tr>
<tr class="separator:af84f2b20490beb1dd0da4b03cf93afac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa423a42208a4fde5f23ab6a28cef24a3" id="r_aa423a42208a4fde5f23ab6a28cef24a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa423a42208a4fde5f23ab6a28cef24a3">FloatToBfloat16_simd</a> (const float *src, bfloat16 *dst, size_t size)</td></tr>
<tr class="separator:aa423a42208a4fde5f23ab6a28cef24a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb00b526459a0db53a2c6ffe0276dd3e" id="r_afb00b526459a0db53a2c6ffe0276dd3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb00b526459a0db53a2c6ffe0276dd3e">Bfloat16ToFloat_simd</a> (const bfloat16 *src, float *dst, size_t size)</td></tr>
<tr class="separator:afb00b526459a0db53a2c6ffe0276dd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44c584c974f95f4866806cee3798742" id="r_af44c584c974f95f4866806cee3798742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af44c584c974f95f4866806cee3798742">FloatToFloat16_ref</a> (const float *src, float16 *dst, size_t size, bool do_clip=false)</td></tr>
<tr class="separator:af44c584c974f95f4866806cee3798742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc22ec6e38a38c7f41484f844dbfbeac" id="r_afc22ec6e38a38c7f41484f844dbfbeac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc22ec6e38a38c7f41484f844dbfbeac">Float16ToFloat_ref</a> (const float16 *src, float *dst, size_t size)</td></tr>
<tr class="separator:afc22ec6e38a38c7f41484f844dbfbeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a50b113345c09b89b45834f31d52df" id="r_a53a50b113345c09b89b45834f31d52df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53a50b113345c09b89b45834f31d52df">FloatToFloat16_simd</a> (const float *src, float16 *dst, size_t size, bool do_clip=false)</td></tr>
<tr class="separator:a53a50b113345c09b89b45834f31d52df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af066434e23720ecd4ddcc51d7a616aef" id="r_af066434e23720ecd4ddcc51d7a616aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af066434e23720ecd4ddcc51d7a616aef">Float16ToFloat_simd</a> (const float16 *src, float *dst, size_t size)</td></tr>
<tr class="separator:af066434e23720ecd4ddcc51d7a616aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77602a69076f938d21d336a0df00f9c4" id="r_a77602a69076f938d21d336a0df00f9c4"><td class="memTemplParams" colspan="2">template&lt;typename InType , typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float, bool THREAD_LOCAL = false&gt; </td></tr>
<tr class="memitem:a77602a69076f938d21d336a0df00f9c4"><td class="memTemplItemLeft" align="right" valign="top">EmbeddingSpMDMKernelSignature&lt; InType, IndexType, OffsetType, OutType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77602a69076f938d21d336a0df00f9c4">GenerateEmbeddingSpMDM</a> (const std::int64_t block_size, bool has_weight, bool normalize_by_lengths, int prefetch=16, bool is_weight_positional=false, bool use_offsets=true, bool is_bf16_out=false, bool is_bf16_in=false)</td></tr>
<tr class="separator:a77602a69076f938d21d336a0df00f9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243ed0e4df7bb7b6c08a930ee71a996b" id="r_a243ed0e4df7bb7b6c08a930ee71a996b"><td class="memTemplParams" colspan="2">template&lt;typename InType , typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float, bool THREAD_LOCAL = false&gt; </td></tr>
<tr class="memitem:a243ed0e4df7bb7b6c08a930ee71a996b"><td class="memTemplItemLeft" align="right" valign="top">EmbeddingSpMDMKernelSignature&lt; InType, IndexType, OffsetType, OutType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a243ed0e4df7bb7b6c08a930ee71a996b">GenerateEmbeddingSpMDMWithStrides</a> (const std::int64_t block_size, bool has_weight, bool normalize_by_lengths, int prefetch=16, bool is_weight_positional=false, bool use_offsets=true, std::int64_t output_stride=-1, std::int64_t input_stride=-1, bool scale_bias_last=true, bool no_bag=false, bool is_bf16_out=false, bool is_bf16_in=false)</td></tr>
<tr class="separator:a243ed0e4df7bb7b6c08a930ee71a996b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e2948ec5f9097f552de8a0458d49e1" id="r_aa4e2948ec5f9097f552de8a0458d49e1"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float&gt; </td></tr>
<tr class="memitem:aa4e2948ec5f9097f552de8a0458d49e1"><td class="memTemplItemLeft" align="right" valign="top">EmbeddingSpMDMKernelSignature&lt; std::uint8_t, IndexType, OffsetType, OutType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4e2948ec5f9097f552de8a0458d49e1">GenerateEmbeddingSpMDMNBit</a> (int bit_rate, const std::int64_t block_size, bool has_weight, bool normalize_by_lengths, int prefetch=16, bool is_weight_positional=false, bool use_offsets=true)</td></tr>
<tr class="separator:aa4e2948ec5f9097f552de8a0458d49e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb137866f8726f5c6cbf150ccc7e5b08" id="r_abb137866f8726f5c6cbf150ccc7e5b08"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float, bool THREAD_LOCAL = false&gt; </td></tr>
<tr class="memitem:abb137866f8726f5c6cbf150ccc7e5b08"><td class="memTemplItemLeft" align="right" valign="top">EmbeddingSpMDMKernelSignature&lt; std::uint8_t, IndexType, OffsetType, OutType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb137866f8726f5c6cbf150ccc7e5b08">GenerateEmbeddingSpMDMNBitWithStrides</a> (int bit_rate, const std::int64_t block_size, bool has_weight, bool normalize_by_lengths, int prefetch=16, bool is_weight_positional=false, bool use_offsets=true, std::int64_t output_stride=-1, std::int64_t input_stride=-1, bool scale_bias_last=true, bool is_bf16_out=false)</td></tr>
<tr class="separator:abb137866f8726f5c6cbf150ccc7e5b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57534e5ede9766d50e536437b499894d" id="r_a57534e5ede9766d50e536437b499894d"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float&gt; </td></tr>
<tr class="memitem:a57534e5ede9766d50e536437b499894d"><td class="memTemplItemLeft" align="right" valign="top">EmbeddingSpMDMKernelSignature&lt; std::uint8_t, IndexType, OffsetType, OutType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57534e5ede9766d50e536437b499894d">GenerateEmbeddingSpMDMFP8WithStrides</a> (const std::int64_t block_size, bool normalize_by_lengths, bool is_weight_positional=false, bool use_offsets=true, std::int64_t output_stride=-1, std::int64_t input_stride=-1, int exponent_bits=4, int exponent_bias=7, bool is_bf16_out=false)</td></tr>
<tr class="separator:a57534e5ede9766d50e536437b499894d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6fe14c3ad83011adb500625ecbff01" id="r_a6d6fe14c3ad83011adb500625ecbff01"><td class="memTemplParams" colspan="2">template&lt;typename InType , typename IndexType , typename OffsetType  = std::int32_t&gt; </td></tr>
<tr class="memitem:a6d6fe14c3ad83011adb500625ecbff01"><td class="memTemplItemLeft" align="right" valign="top">EmbeddingSpMDMRowWiseSparseKernelSignature&lt; InType, IndexType, OffsetType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d6fe14c3ad83011adb500625ecbff01">GenerateEmbeddingSpMDMRowWiseSparse</a> (const std::int64_t block_size, bool has_weight, bool normalize_by_lengths, int prefetch=16, bool is_weight_positional=false, bool use_offsets=true)</td></tr>
<tr class="separator:a6d6fe14c3ad83011adb500625ecbff01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d2220ddfc7d5c9820fd03b73101d37" id="r_aa7d2220ddfc7d5c9820fd03b73101d37"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename OffsetType  = std::int32_t&gt; </td></tr>
<tr class="memitem:aa7d2220ddfc7d5c9820fd03b73101d37"><td class="memTemplItemLeft" align="right" valign="top">EmbeddingSpMDMRowWiseSparseKernelSignature&lt; std::uint8_t, IndexType, OffsetType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7d2220ddfc7d5c9820fd03b73101d37">GenerateEmbeddingSpMDMNBitRowWiseSparse</a> (int bit_rate, const std::int64_t block_size, bool has_weight, bool normalize_by_lengths, int prefetch=16, bool is_weight_positional=false, bool use_offsets=true)</td></tr>
<tr class="separator:aa7d2220ddfc7d5c9820fd03b73101d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ceef30c1643dd1a87b1a0753b52e87" id="r_a90ceef30c1643dd1a87b1a0753b52e87"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename OffsetType  = std::int32_t, typename DataType  = float&gt; </td></tr>
<tr class="memitem:a90ceef30c1643dd1a87b1a0753b52e87"><td class="memTemplItemLeft" align="right" valign="top">RowWiseSparseAdaGradFusedSignature&lt; IndexType, OffsetType, DataType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90ceef30c1643dd1a87b1a0753b52e87">GenerateRowWiseSparseAdaGradFused</a> (int block_size, int prefetch=16, bool use_offsets=true, bool use_stochastic_rounding=true, int grad_stride=-1)</td></tr>
<tr class="separator:a90ceef30c1643dd1a87b1a0753b52e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c69d65ed666a9f46dc4763be70cdf6" id="r_a28c69d65ed666a9f46dc4763be70cdf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28c69d65ed666a9f46dc4763be70cdf6">PackA</a> (int nrow, int ncol, const float *from, int ldim, float *to)</td></tr>
<tr class="separator:a28c69d65ed666a9f46dc4763be70cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e9634d4e2366ed6f2181ae7e7b17b2" id="r_ac2e9634d4e2366ed6f2181ae7e7b17b2"><td class="memTemplParams" colspan="2">template&lt;QuantizationGranularity Q_GRAN, typename BIAS_TYPE  = std::int32_t&gt; </td></tr>
<tr class="memitem:ac2e9634d4e2366ed6f2181ae7e7b17b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac2e9634d4e2366ed6f2181ae7e7b17b2">depthwise_2d_same_pad</a> (int N, int H, int W, int IC, int OC, int stride_h, int stride_w, std::int32_t A_zero_point, const std::uint8_t *A, const std::int32_t *B_zero_point, const PackedDepthWiseConvMatrix &amp;Bp, const float *C_multiplier, std::int32_t C_zero_point, std::uint8_t *C, const std::int32_t *col_offsets, const BIAS_TYPE *bias, bool fuse_relu=false, const float *act_times_w_scale=nullptr, int thread_id=0, int num_threads=1)</td></tr>
<tr class="separator:ac2e9634d4e2366ed6f2181ae7e7b17b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfa499fd1b485bc3e457842343bca57" id="r_a0bfa499fd1b485bc3e457842343bca57"><td class="memTemplParams" colspan="2">template&lt;QuantizationGranularity Q_GRAN, typename BIAS_TYPE  = std::int32_t&gt; </td></tr>
<tr class="memitem:a0bfa499fd1b485bc3e457842343bca57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bfa499fd1b485bc3e457842343bca57">depthwise_3d_same_pad</a> (const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; 3 &gt; &amp;conv_p, std::int32_t A_zero_point, const std::uint8_t *A, const std::int32_t *B_zero_point, const PackedDepthWiseConvMatrix &amp;Bp, const float *C_multiplier, std::int32_t C_zero_point, std::uint8_t *C, const std::int32_t *col_offsets, const BIAS_TYPE *bias, bool fuse_relu=false, const float *act_times_w_scale=nullptr, int thread_id=0, int num_threads=1)</td></tr>
<tr class="separator:a0bfa499fd1b485bc3e457842343bca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1671cc912f6aa4bab678a0d255c8a690" id="r_a1671cc912f6aa4bab678a0d255c8a690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1671cc912f6aa4bab678a0d255c8a690">SparseDenseMM</a> (int M, int N, const int *row_ptr, const int *col_idx, const float *values, const float *B, int ldb, float *C, int ldc, bool accum=false)</td></tr>
<tr class="separator:a1671cc912f6aa4bab678a0d255c8a690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3350c03dc2d62e8e434332d088f6a895" id="r_a3350c03dc2d62e8e434332d088f6a895"><td class="memTemplParams" colspan="2">template&lt;typename T , bool LEGACY = true&gt; </td></tr>
<tr class="memitem:a3350c03dc2d62e8e434332d088f6a895"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3350c03dc2d62e8e434332d088f6a895">Quantize</a> (float src, std::int32_t zero_point, float scale, int result_precision, bool result_is_signed=std::is_signed&lt; T &gt;::value)</td></tr>
<tr class="separator:a3350c03dc2d62e8e434332d088f6a895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5705b5705425abc8f72fe339c2ae91" id="r_ga7a5705b5705425abc8f72fe339c2ae91"><td class="memTemplParams" colspan="2">template&lt;typename T , layout_t LAYOUT = layout_t::KCX&gt; </td></tr>
<tr class="memitem:ga7a5705b5705425abc8f72fe339c2ae91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fbgemm-quant-utils-generic.html#ga7a5705b5705425abc8f72fe339c2ae91">QuantizeGroupwise</a> (const float *src, int K, int C, int X, int G, const float *scales, const std::int32_t *zero_points, T *dst)</td></tr>
<tr class="separator:ga7a5705b5705425abc8f72fe339c2ae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51ab0f363fbcdf8ffa0a561884225d9" id="r_gaa51ab0f363fbcdf8ffa0a561884225d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa51ab0f363fbcdf8ffa0a561884225d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fbgemm-quant-utils-generic.html#gaa51ab0f363fbcdf8ffa0a561884225d9">FusedQuantizeDequantize</a> (const float *src, float *dst, std::int64_t len, const <a class="el" href="structfbgemm_1_1_tensor_quantization_params.html">TensorQuantizationParams</a> &amp;qparams, int thread_id=0, int num_threads=1, float noise_ratio=0.0f)</td></tr>
<tr class="separator:gaa51ab0f363fbcdf8ffa0a561884225d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b77c8540e630305db9a5f30a84e7e5b" id="r_ga6b77c8540e630305db9a5f30a84e7e5b"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:ga6b77c8540e630305db9a5f30a84e7e5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fbgemm-quant-utils-generic.html#ga6b77c8540e630305db9a5f30a84e7e5b">FloatOrHalfToFusedNBitRowwiseQuantizedSBHalf</a> (int bit_rate, const InputType *input, size_t input_rows, int input_columns, std::uint8_t *output)</td></tr>
<tr class="separator:ga6b77c8540e630305db9a5f30a84e7e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2ca55a7d2d5c2dbba337ee2e585f6a" id="r_a2b2ca55a7d2d5c2dbba337ee2e585f6a"><td class="memTemplParams" colspan="2">template&lt;typename OutputType &gt; </td></tr>
<tr class="memitem:a2b2ca55a7d2d5c2dbba337ee2e585f6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b2ca55a7d2d5c2dbba337ee2e585f6a">FusedNBitRowwiseQuantizedSBHalfToFloatOrHalf</a> (int bit_rate, const uint8_t *input, size_t input_rows, int input_columns, OutputType *output)</td></tr>
<tr class="separator:a2b2ca55a7d2d5c2dbba337ee2e585f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafa94e239d016cf273ad0597152b86c" id="r_afafa94e239d016cf273ad0597152b86c"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:afafa94e239d016cf273ad0597152b86c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afafa94e239d016cf273ad0597152b86c">FloatOrHalfToFused8BitRowwiseQuantizedSBFloat</a> (const InputType *input, size_t input_rows, int input_columns, std::uint8_t *output)</td></tr>
<tr class="separator:afafa94e239d016cf273ad0597152b86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42aefaaf238d065625a64a757f998eef" id="r_a42aefaaf238d065625a64a757f998eef"><td class="memTemplParams" colspan="2">template&lt;typename OutputType &gt; </td></tr>
<tr class="memitem:a42aefaaf238d065625a64a757f998eef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42aefaaf238d065625a64a757f998eef">Fused8BitRowwiseQuantizedSBFloatToFloatOrHalf</a> (const uint8_t *input, size_t input_rows, int input_columns, OutputType *output)</td></tr>
<tr class="separator:a42aefaaf238d065625a64a757f998eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89426896d5c7b1f1b5db8ebaf201547" id="r_ad89426896d5c7b1f1b5db8ebaf201547"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:ad89426896d5c7b1f1b5db8ebaf201547"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad89426896d5c7b1f1b5db8ebaf201547">FloatOrHalfToFusedNBitRowwiseQuantizedSBHalfRef</a> (int bit_rate, const InputType *input, size_t input_rows, int input_columns, std::uint8_t *output)</td></tr>
<tr class="separator:ad89426896d5c7b1f1b5db8ebaf201547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cba6dad217715349653862b3e691057" id="r_a7cba6dad217715349653862b3e691057"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a7cba6dad217715349653862b3e691057"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7cba6dad217715349653862b3e691057">FloatOrHalfToFused8BitRowwiseQuantizedSBFloatRef</a> (const InputType *input, size_t input_rows, int input_columns, std::uint8_t *output)</td></tr>
<tr class="separator:a7cba6dad217715349653862b3e691057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee65a9c68614b76ffdf2b3bc11b4618" id="r_adee65a9c68614b76ffdf2b3bc11b4618"><td class="memTemplParams" colspan="2">template&lt;typename OutputType &gt; </td></tr>
<tr class="memitem:adee65a9c68614b76ffdf2b3bc11b4618"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adee65a9c68614b76ffdf2b3bc11b4618">FusedNBitRowwiseQuantizedSBHalfToFloatOrHalfRef</a> (int bit_rate, const uint8_t *input, size_t input_rows, int input_columns, OutputType *output)</td></tr>
<tr class="separator:adee65a9c68614b76ffdf2b3bc11b4618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19217d3a8551a7b251ecb1eba79669bc" id="r_a19217d3a8551a7b251ecb1eba79669bc"><td class="memTemplParams" colspan="2">template&lt;typename OutputType &gt; </td></tr>
<tr class="memitem:a19217d3a8551a7b251ecb1eba79669bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19217d3a8551a7b251ecb1eba79669bc">Fused8BitRowwiseQuantizedSBFloatToFloatOrHalfRef</a> (const uint8_t *input, size_t input_rows, int input_columns, OutputType *output)</td></tr>
<tr class="separator:a19217d3a8551a7b251ecb1eba79669bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b9e26f3c7ff032c5316bcc0167c23b" id="r_ga94b9e26f3c7ff032c5316bcc0167c23b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fbgemm-quant-utils-avx2.html#ga94b9e26f3c7ff032c5316bcc0167c23b">Xor128</a> (void)</td></tr>
<tr class="separator:ga94b9e26f3c7ff032c5316bcc0167c23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e2b96889b039f101e24855e163021b" id="r_ga92e2b96889b039f101e24855e163021b"><td class="memTemplParams" colspan="2">template&lt;bool A_SYMMETRIC, bool B_SYMMETRIC, QuantizationGranularity Q_GRAN, bool HAS_BIAS, bool FUSE_RELU, typename BIAS_TYPE  = std::int32_t, bool DIRECT = false&gt; </td></tr>
<tr class="memitem:ga92e2b96889b039f101e24855e163021b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fbgemm-quant-utils-avx2.html#ga92e2b96889b039f101e24855e163021b">requantizeOutputProcessingAvx2</a> (std::uint8_t *out, const std::int32_t *inp, const <a class="el" href="structfbgemm_1_1block__type__t.html">block_type_t</a> &amp;block, int ld_out, int ld_in, const <a class="el" href="structfbgemm_1_1requantization_params__t.html">requantizationParams_t</a>&lt; BIAS_TYPE &gt; &amp;r)</td></tr>
<tr class="separator:ga92e2b96889b039f101e24855e163021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b2ed3537f97d130f8ed039bc9aa463" id="r_gab1b2ed3537f97d130f8ed039bc9aa463"><td class="memTemplParams" colspan="2">template&lt;bool A_SYMMETRIC, bool B_SYMMETRIC, QuantizationGranularity Q_GRAN, bool HAS_BIAS, bool FUSE_RELU, int C_PER_G, typename BIAS_TYPE  = std::int32_t&gt; </td></tr>
<tr class="memitem:gab1b2ed3537f97d130f8ed039bc9aa463"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fbgemm-quant-utils-avx512.html#gab1b2ed3537f97d130f8ed039bc9aa463">requantizeOutputProcessingGConvAvx512</a> (std::uint8_t *out, const std::int32_t *inp, const <a class="el" href="structfbgemm_1_1block__type__t.html">block_type_t</a> &amp;block, int ld_out, int ld_in, const <a class="el" href="structfbgemm_1_1requantization_params__t.html">requantizationParams_t</a>&lt; BIAS_TYPE &gt; &amp;r)</td></tr>
<tr class="separator:gab1b2ed3537f97d130f8ed039bc9aa463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d995b583abb4b09927c90f66e3b1463" id="r_a9d995b583abb4b09927c90f66e3b1463"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d995b583abb4b09927c90f66e3b1463"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d995b583abb4b09927c90f66e3b1463">compare_buffers</a> (const T *ref, const T *test, int m, int n, int ld, size_t max_mismatches_to_report, float atol=1e-3)</td></tr>
<tr class="separator:a9d995b583abb4b09927c90f66e3b1463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfee356e154f8b2f88c725885b1dbc11" id="r_adfee356e154f8b2f88c725885b1dbc11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfee356e154f8b2f88c725885b1dbc11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfee356e154f8b2f88c725885b1dbc11">printMatrix</a> (<a class="el" href="#ae28c9cc48e43e99cb778d60ba35c0fbf">matrix_op_t</a> trans, const T *inp, size_t R, size_t C, size_t ld, std::string name)</td></tr>
<tr class="separator:adfee356e154f8b2f88c725885b1dbc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b4ad78ae16c6e6782f82e1ff4012a8" id="r_a75b4ad78ae16c6e6782f82e1ff4012a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75b4ad78ae16c6e6782f82e1ff4012a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75b4ad78ae16c6e6782f82e1ff4012a8">transpose_simd</a> (int64_t M, int64_t N, const T *src, int64_t ld_src, T *dst, int64_t ld_dst)</td></tr>
<tr class="separator:a75b4ad78ae16c6e6782f82e1ff4012a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af150495d47d5ccb1670524166fd9b45d" id="r_af150495d47d5ccb1670524166fd9b45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af150495d47d5ccb1670524166fd9b45d">fbgemmForceIsa</a> (<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a>)</td></tr>
<tr class="separator:af150495d47d5ccb1670524166fd9b45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d17a4894f822f7afd5c79407bbf91d5" id="r_a9d17a4894f822f7afd5c79407bbf91d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d17a4894f822f7afd5c79407bbf91d5">fbgemmEnableAvx512Ymm</a> (bool)</td></tr>
<tr class="separator:a9d17a4894f822f7afd5c79407bbf91d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be92a96ebd3c0d9bc9f9c0d0c537969" id="r_a2be92a96ebd3c0d9bc9f9c0d0c537969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2be92a96ebd3c0d9bc9f9c0d0c537969">fbgemmInstructionSet</a> ()</td></tr>
<tr class="separator:a2be92a96ebd3c0d9bc9f9c0d0c537969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e1a7f0b1935835ad95a52aa4f56eb8" id="r_a26e1a7f0b1935835ad95a52aa4f56eb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e1a7f0b1935835ad95a52aa4f56eb8">fbgemmGet2DPartition</a> (int m, int n, int nthreads, int n_align, double aspect_ratio)</td></tr>
<tr class="separator:a26e1a7f0b1935835ad95a52aa4f56eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9cb71c5c3a79935f7146f05510bb19" id="r_abf9cb71c5c3a79935f7146f05510bb19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf9cb71c5c3a79935f7146f05510bb19">fbgemmPartition1D</a> (int thread_id, int num_threads, std::int64_t total_work, std::int64_t &amp;start, std::int64_t &amp;end)</td></tr>
<tr class="separator:abf9cb71c5c3a79935f7146f05510bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d6321b283eaa5a8ddaaa96ea22c62f" id="r_ae6d6321b283eaa5a8ddaaa96ea22c62f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d6321b283eaa5a8ddaaa96ea22c62f">fbgemmPartition1DBlocked</a> (int thread_id, int num_threads, std::int64_t total_work, int block_size, std::int64_t &amp;start, std::int64_t &amp;end)</td></tr>
<tr class="separator:ae6d6321b283eaa5a8ddaaa96ea22c62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06c4dd5673e6b3df1dfe3617fdc919d" id="r_aa06c4dd5673e6b3df1dfe3617fdc919d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> instSet, typename T , typename std::enable_if&lt; instSet==inst_set_t::avx2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa06c4dd5673e6b3df1dfe3617fdc919d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa06c4dd5673e6b3df1dfe3617fdc919d">gen16BitVectorOne</a> (x86::Emitter *a, T dest)</td></tr>
<tr class="separator:aa06c4dd5673e6b3df1dfe3617fdc919d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56904bd84399e10104d286e0e10a2d7" id="r_aa56904bd84399e10104d286e0e10a2d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> instSet, typename T , typename std::enable_if&lt; instSet==inst_set_t::avx2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa56904bd84399e10104d286e0e10a2d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa56904bd84399e10104d286e0e10a2d7">emitLoadDWord</a> (x86::Emitter *a, T dest, const x86::Mem &amp;ptr)</td></tr>
<tr class="separator:aa56904bd84399e10104d286e0e10a2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602ac18c0e6c32448ff8d21818bded38" id="r_a602ac18c0e6c32448ff8d21818bded38"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> instSet, typename T , typename std::enable_if&lt; instSet==inst_set_t::avx512||instSet==inst_set_t::avx512_ymm||instSet==inst_set_t::avx512_vnni||instSet==inst_set_t::avx512_vnni_ymm, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a602ac18c0e6c32448ff8d21818bded38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a602ac18c0e6c32448ff8d21818bded38">emitExtractHalfVector</a> (x86::Emitter *a, x86::Ymm half, const x86::Zmm vec, int idx)</td></tr>
<tr class="separator:a602ac18c0e6c32448ff8d21818bded38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c476c8ddbed58f3f6b4395dd55ed2a3" id="r_a3c476c8ddbed58f3f6b4395dd55ed2a3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_same&lt; T, x86::Ymm &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a3c476c8ddbed58f3f6b4395dd55ed2a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c476c8ddbed58f3f6b4395dd55ed2a3">gen8BitVectorOne</a> (x86::Emitter *a, T dest)</td></tr>
<tr class="separator:a3c476c8ddbed58f3f6b4395dd55ed2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a15434be774f5beeb39e4fe225d6fb9" id="r_a2a15434be774f5beeb39e4fe225d6fb9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> INST_SET, typename std::enable_if&lt; INST_SET==inst_set_t::avx2||INST_SET==inst_set_t::avx512, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a2a15434be774f5beeb39e4fe225d6fb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a15434be774f5beeb39e4fe225d6fb9">genU8I8S32FMA</a> (x86::Emitter *a, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t aReg, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t bReg, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t cReg, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t oneReg16Bit, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t tmpReg)</td></tr>
<tr class="separator:a2a15434be774f5beeb39e4fe225d6fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ddfdb1cd3e41712844257212fcb050" id="r_aa9ddfdb1cd3e41712844257212fcb050"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> INST_SET, typename std::enable_if&lt; INST_SET==inst_set_t::avx2||INST_SET==inst_set_t::avx512, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa9ddfdb1cd3e41712844257212fcb050"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9ddfdb1cd3e41712844257212fcb050">genU8Sum4</a> (x86::Emitter *a, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t src, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t dest, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t oneReg16Bit, typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t tmpReg)</td></tr>
<tr class="separator:aa9ddfdb1cd3e41712844257212fcb050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3535bf91ff758b3bd13929bf9f211c90" id="r_a3535bf91ff758b3bd13929bf9f211c90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3535bf91ff758b3bd13929bf9f211c90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3535bf91ff758b3bd13929bf9f211c90">genU8Sum8</a> (x86::Emitter *a, T src, T dest, T tmpReg)</td></tr>
<tr class="separator:a3535bf91ff758b3bd13929bf9f211c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a50b707287c0456d23e735846b144c0" id="r_a3a50b707287c0456d23e735846b144c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a50b707287c0456d23e735846b144c0">initCRegs</a> (x86::Emitter *a, int rowRegs, int colRegs)</td></tr>
<tr class="separator:a3a50b707287c0456d23e735846b144c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87b23be5587e267db6ab7d2b97c6915" id="r_ab87b23be5587e267db6ab7d2b97c6915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab87b23be5587e267db6ab7d2b97c6915">requantize_u8acc32_ref</a> (int M, int N, int ld, const std::int32_t *inp, std::uint8_t *out, std::int32_t C_multiplier, std::int32_t C_right_shift, std::int32_t C_zero_point, std::int32_t A_zero_point, std::int32_t B_zero_point, const std::int32_t *row_offsets, const std::int32_t *col_offsets, const std::int32_t *bias, bool fuse_relu=false)</td></tr>
<tr class="separator:ab87b23be5587e267db6ab7d2b97c6915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798fea9136d48e1cd4c8a2926fb869ed" id="r_a798fea9136d48e1cd4c8a2926fb869ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a798fea9136d48e1cd4c8a2926fb869ed">requantize_u8acc32_ref</a> (int M, int N, int ld, const std::int32_t *inp, std::uint8_t *out, const float *C_multiplier, std::int32_t C_zero_point, std::int32_t A_zero_point, const std::int32_t *B_zero_point, const std::int32_t *row_offsets, const std::int32_t *col_offsets, const std::int32_t *bias, int ncols_per_quant_group, bool fuse_relu=false)</td></tr>
<tr class="separator:a798fea9136d48e1cd4c8a2926fb869ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f66af5e8e787dc1ff6893ac75ae161f" id="r_a0f66af5e8e787dc1ff6893ac75ae161f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f66af5e8e787dc1ff6893ac75ae161f">col_offsets_with_zero_pt_s8acc32_ref</a> (int K, int N, int ld, const std::int8_t *Bint8, const std::int32_t *B_zero_point, std::int32_t *col_offsets, int ncols_per_quant_group)</td></tr>
<tr class="separator:a0f66af5e8e787dc1ff6893ac75ae161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f19d1389f9e99cc0daded599b1f1fd4" id="r_a4f19d1389f9e99cc0daded599b1f1fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f19d1389f9e99cc0daded599b1f1fd4">spmdm_ref</a> (int M, const std::uint8_t *A, int lda, <a class="el" href="classfbgemm_1_1_compressed_sparse_column.html">CompressedSparseColumn</a> &amp;B, bool accumulation, std::int32_t *C, int ldc, int groups=1)</td></tr>
<tr class="separator:a4f19d1389f9e99cc0daded599b1f1fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f04df11e31dd656955d1bd1f8a7893d" id="r_a3f04df11e31dd656955d1bd1f8a7893d"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a3f04df11e31dd656955d1bd1f8a7893d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f04df11e31dd656955d1bd1f8a7893d">sparse_adagrad_ref</a> (int num_rows, int block_size, std::uint64_t param_size, float *w, const float *g, float *h, const IndexType *indices, float epsilon, float lr, float weight_decay=0.f, const double *counter=nullptr, const int64_t counter_halflife=0)</td></tr>
<tr class="separator:a3f04df11e31dd656955d1bd1f8a7893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bee8daea3756d030209a6815db314d9" id="r_a3bee8daea3756d030209a6815db314d9"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a3bee8daea3756d030209a6815db314d9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bee8daea3756d030209a6815db314d9">rowwise_sparse_adagrad_ref</a> (int num_rows, int block_size, std::uint64_t param_size, float *w, const float *g, float *h, const IndexType *indices, float epsilon, float lr, float weight_decay=0.f, const double *counter=nullptr, const int64_t counter_halflife=0)</td></tr>
<tr class="separator:a3bee8daea3756d030209a6815db314d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18832d0507cb6d8bce78371b97f66479" id="r_a18832d0507cb6d8bce78371b97f66479"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18832d0507cb6d8bce78371b97f66479"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18832d0507cb6d8bce78371b97f66479">transpose_ref</a> (int64_t M, int64_t N, const T *src, int64_t ld_src, T *dst, int64_t ld_dst)</td></tr>
<tr class="separator:a18832d0507cb6d8bce78371b97f66479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Top level include file for FBGEMM. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5356ce4b0771923d6eee8b3692afd2f3" name="a5356ce4b0771923d6eee8b3692afd2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5356ce4b0771923d6eee8b3692afd2f3">&#9670;&#160;</a></span>impl_type_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a5356ce4b0771923d6eee8b3692afd2f3">impl_type_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Typed enum for implementation type. </p>
<p>ref is reference and opt is optimized. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af84f2b20490beb1dd0da4b03cf93afac" name="af84f2b20490beb1dd0da4b03cf93afac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84f2b20490beb1dd0da4b03cf93afac">&#9670;&#160;</a></span>Bfloat16ToFloat_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bfloat16ToFloat_ref </td>
          <td>(</td>
          <td class="paramtype">const bfloat16 *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ Transform all entries in a matrix from bfloat16 to fp32: reference implementation. </p>

</div>
</div>
<a id="afb00b526459a0db53a2c6ffe0276dd3e" name="afb00b526459a0db53a2c6ffe0276dd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb00b526459a0db53a2c6ffe0276dd3e">&#9670;&#160;</a></span>Bfloat16ToFloat_simd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bfloat16ToFloat_simd </td>
          <td>(</td>
          <td class="paramtype">const bfloat16 *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ Transform all entries in a matrix from bfloat16 to fp32: simd implementation. </p>

</div>
</div>
<a id="a0f66af5e8e787dc1ff6893ac75ae161f" name="a0f66af5e8e787dc1ff6893ac75ae161f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f66af5e8e787dc1ff6893ac75ae161f">&#9670;&#160;</a></span>col_offsets_with_zero_pt_s8acc32_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void col_offsets_with_zero_pt_s8acc32_ref </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>K</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ld</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int8_t *</td>          <td class="paramname"><span class="paramname"><em>Bint8</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>B_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>col_offsets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncols_per_quant_group</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference implementation to compute adjusted col_offsets (sum of columns of B and adjusted with B_zero_point) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncols_per_quant_group</td><td>see ncols_per_quant_group in requantize_u8acc32_ref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d995b583abb4b09927c90f66e3b1463" name="a9d995b583abb4b09927c90f66e3b1463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d995b583abb4b09927c90f66e3b1463">&#9670;&#160;</a></span>compare_buffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int compare_buffers </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>ref</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>test</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>m</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ld</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_mismatches_to_report</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>atol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to compare data in two buffers for closeness/equality. </p>
<p>Compare the reference and test result matrix to check the correctness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The buffer for the reference result matrix. </td></tr>
    <tr><td class="paramname">test</td><td>The buffer for the test result matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The height of the reference and test result matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The width of the reference and test result matrix. </td></tr>
    <tr><td class="paramname">ld</td><td>The leading dimension of the reference and test result matrix. </td></tr>
    <tr><td class="paramname">max_mismatches_to_report</td><td>The maximum number of tolerable mismatches to report. </td></tr>
    <tr><td class="paramname">atol</td><td>The tolerable error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>If the number of mismatches for reference and test result matrix exceeds max_mismatches_to_report. </td></tr>
    <tr><td class="paramname">true</td><td>If the number of mismatches for reference and test result matrix is tolerable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5bda89769bca9a01ddf81591f20ef02" name="ad5bda89769bca9a01ddf81591f20ef02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bda89769bca9a01ddf81591f20ef02">&#9670;&#160;</a></span>ConvFastPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SPATIAL_DIM = 2, typename ACC_T  = std::int32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae779e18e5742efa69f340bcb616acdb2">optimized_conv_t</a> ConvFastPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; SPATIAL_DIM &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>conv_p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns which fast path to take. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SPATIAL_DIM</td><td>It's 2 for 2D convolutions and 3 for 3D convolutions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optimized_conv_t::depthwise, optimized_conv_t::groupwise or optimized_conv_t::im2col </dd></dl>

</div>
</div>
<a id="ac2e9634d4e2366ed6f2181ae7e7b17b2" name="ac2e9634d4e2366ed6f2181ae7e7b17b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e9634d4e2366ed6f2181ae7e7b17b2">&#9670;&#160;</a></span>depthwise_2d_same_pad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuantizationGranularity Q_GRAN, typename BIAS_TYPE  = std::int32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void depthwise_2d_same_pad </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>H</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>IC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>OC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stride_h</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stride_w</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>A_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>A</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>B_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedDepthWiseConvMatrix &amp;</td>          <td class="paramname"><span class="paramname"><em>Bp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>C_multiplier</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>C_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>col_offsets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BIAS_TYPE *</td>          <td class="paramname"><span class="paramname"><em>bias</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fuse_relu</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>act_times_w_scale</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thread_id</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Depth-wise convolution that results in the same output feature size as the input feature. That is PAD_T = PAD_B = (R - 1) / 2 and PAD_L = PAD_R = (S - 1) / 2. This function also does requantization. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_offsets</td><td>nullptr if col_offsets are folded into bias </td></tr>
    <tr><td class="paramname">act_times_w_scale</td><td>Only used if BIAS_TYPE is float, i.e., bias is unquantized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bfa499fd1b485bc3e457842343bca57" name="a0bfa499fd1b485bc3e457842343bca57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfa499fd1b485bc3e457842343bca57">&#9670;&#160;</a></span>depthwise_3d_same_pad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuantizationGranularity Q_GRAN, typename BIAS_TYPE  = std::int32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void depthwise_3d_same_pad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>conv_p</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>A_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>A</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>B_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedDepthWiseConvMatrix &amp;</td>          <td class="paramname"><span class="paramname"><em>Bp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>C_multiplier</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>C_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>col_offsets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BIAS_TYPE *</td>          <td class="paramname"><span class="paramname"><em>bias</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fuse_relu</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>act_times_w_scale</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thread_id</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_offsets</td><td>nullptr if col_offsets are folded into bias </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a602ac18c0e6c32448ff8d21818bded38" name="a602ac18c0e6c32448ff8d21818bded38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602ac18c0e6c32448ff8d21818bded38">&#9670;&#160;</a></span>emitExtractHalfVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> instSet, typename T , typename std::enable_if&lt; instSet==inst_set_t::avx512||instSet==inst_set_t::avx512_ymm||instSet==inst_set_t::avx512_vnni||instSet==inst_set_t::avx512_vnni_ymm, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emitExtractHalfVector </td>
          <td>(</td>
          <td class="paramtype">x86::Emitter *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">x86::Ymm</td>          <td class="paramname"><span class="paramname"><em>half</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const x86::Zmm</td>          <td class="paramname"><span class="paramname"><em>vec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit partial extract from Wide regiter to Half Register, eg. Zmm -&gt; Ymm or Ymm -&gt; Xmm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">instSet</td><td>instruction set to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">half</td><td>Destination (half) vector register </td></tr>
    <tr><td class="paramname">vec</td><td>Source (full) vector register </td></tr>
    <tr><td class="paramname">idx</td><td>Index of of the half vector 0 or 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa56904bd84399e10104d286e0e10a2d7" name="aa56904bd84399e10104d286e0e10a2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56904bd84399e10104d286e0e10a2d7">&#9670;&#160;</a></span>emitLoadDWord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> instSet, typename T , typename std::enable_if&lt; instSet==inst_set_t::avx2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emitLoadDWord </td>
          <td>(</td>
          <td class="paramtype">x86::Emitter *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>dest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const x86::Mem &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit instruction do load 32-bit integer. AVX512 has different instrunction to load registers with index &gt;= 16. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Register type of destination, e.g., x86::Ymm or x86::Zmm</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination vector register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc9d2af7ea01634fd2e5bef0e6baa0ab" name="adc9d2af7ea01634fd2e5bef0e6baa0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9d2af7ea01634fd2e5bef0e6baa0ab">&#9670;&#160;</a></span>fbgemmConv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename processOutputType , int SPATIAL_DIM = 2, typename ACC_T  = std::int32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int fbgemmConv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; SPATIAL_DIM &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>conv_p</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>activations</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfbgemm_1_1_pack_weights_for_conv.html">PackWeightsForConv</a>&lt; SPATIAL_DIM, std::int8_t, ACC_T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packed_weights</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename processOutputType::outType *</td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>outBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">processOutputType &amp;</td>          <td class="paramname"><span class="paramname"><em>outProcess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thread_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfbgemm_1_1_blocking_factors.html">BlockingFactors</a> *</td>          <td class="paramname"><span class="paramname"><em>blocking_params</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs convolution using fastest path available. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SPATIAL_DIM</td><td>It's 2 for 2D convolutions and 3 for 3D convolutions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d17a4894f822f7afd5c79407bbf91d5" name="a9d17a4894f822f7afd5c79407bbf91d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d17a4894f822f7afd5c79407bbf91d5">&#9670;&#160;</a></span>fbgemmEnableAvx512Ymm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbgemmEnableAvx512Ymm </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable AVX512-256 path for Intel(r) Xeon(r) D servers. </p>
<p>Enables AVX512-256 if appriate. Inteded for Skylake based Xeon-D processors, wherein AXV512-256 is preferred due to higher Turbo frequencis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>True enables / False disables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af150495d47d5ccb1670524166fd9b45d" name="af150495d47d5ccb1670524166fd9b45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af150495d47d5ccb1670524166fd9b45d">&#9670;&#160;</a></span>fbgemmForceIsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbgemmForceIsa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a></td>          <td class="paramname"><span class="paramname"><em>isa</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly set instruction set to be used. </p>
<p>Force specific architecure to for GEMM kernel execution overides FBGEMM_ENABLE_AVX512_256 env. variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isa</td><td>the ISA to enforce, supported optionsi AVX2 inst_set_t::avx2 AVX512 inst_set_t::avx512 AVX512_E1 inst_set_t::avx512_vnni AVX512_256 inst_set_t::avx512_ymm AVX512_E1_256 inst_set_t::avx512_vnni_ymm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26e1a7f0b1935835ad95a52aa4f56eb8" name="a26e1a7f0b1935835ad95a52aa4f56eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e1a7f0b1935835ad95a52aa4f56eb8">&#9670;&#160;</a></span>fbgemmGet2DPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbgemmGet2DPartition </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>m</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nthreads</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_align</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>aspect_ratio</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A heuristic algorithm to partition the threads across m and n dimensions for parallelization, ensuring the ratio between the number of rows allocated to each thread in the m dimension and the number of columns allocated to each thread in the n dimension is approximately aspect_ratio. </p>
<p>The less aspect_ratio is, the more favorable it is to parallelize the m dimension over the n dimension. </p>

</div>
</div>
<a id="a5780ef4a16a1682740af29283360caa4" name="a5780ef4a16a1682740af29283360caa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5780ef4a16a1682740af29283360caa4">&#9670;&#160;</a></span>fbgemmGroupwiseConv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename packed_W , typename outType , bool FUSE_RELU, QuantizationGranularity Q_GRAN, int SPATIAL_DIM = 2, typename BIAS_TYPE  = std::int32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fbgemmGroupwiseConv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; SPATIAL_DIM &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>conv_param</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>activations</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>a_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>rowOffsetBuf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">packed_W &amp;</td>          <td class="paramname"><span class="paramname"><em>packed_weights</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outType *</td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>outBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfbgemm_1_1_re_quantize_output.html">ReQuantizeOutput</a>&lt; FUSE_RELU, Q_GRAN, BIAS_TYPE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outProcess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thread_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform small-channels-per-group groupwise convolution Note: Currently threading is not supported. This function does nothing for thread_ids &gt; 0, i.e., returns early. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowOffsetBuf</td><td>nullptr if B uses symmetric quantization Note: Currently threading is not supported. This function does nothing for thread_ids &gt; 0, i.e., returns early. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2be92a96ebd3c0d9bc9f9c0d0c537969" name="a2be92a96ebd3c0d9bc9f9c0d0c537969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be92a96ebd3c0d9bc9f9c0d0c537969">&#9670;&#160;</a></span>fbgemmInstructionSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> fbgemmInstructionSet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve current CPU instruction set. </p>
<p>Determine the best available x86 machine ISA to be used for GEMM kernels. FBGEMM_ENABLE_AVX512_256 env. or <a class="el" href="#af150495d47d5ccb1670524166fd9b45d" title="Explicitly set instruction set to be used.">fbgemmForceIsa()</a> are set forces to specific architecture if supported by the processor. Enforcing on Skylake to AVX2 will execute AVX2 version of the kernel However, enforcing AVX512-256 on Broadwell will fail, and AVX2 version of the kernels will be executed. </p>

</div>
</div>
<a id="a1f01b8b3f8fea3e9c8ccc2aed30ba70a" name="a1f01b8b3f8fea3e9c8ccc2aed30ba70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f01b8b3f8fea3e9c8ccc2aed30ba70a">&#9670;&#160;</a></span>fbgemmPacked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename packingAMatrix , typename packingBMatrix , typename cT , typename processOutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fbgemmPacked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfbgemm_1_1_pack_matrix.html">PackMatrix</a>&lt; packingAMatrix, typename packingAMatrix::inpType, typename packingAMatrix::accType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packA</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfbgemm_1_1_pack_matrix.html">PackMatrix</a>&lt; packingBMatrix, typename packingBMatrix::inpType, typename packingBMatrix::accType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packB</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>C_buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>ldc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const processOutputType &amp;</td>          <td class="paramname"><span class="paramname"><em>outProcess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thread_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfbgemm_1_1_blocking_factors.html">BlockingFactors</a> *</td>          <td class="paramname"><span class="paramname"><em>blocking_params</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix B must be prepacked. For matrix A, packA.pack function is called to pack it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">packingAMatrix</td><td>processing of A matrix while packing, e.g., <a class="el" href="classfbgemm_1_1_pack_a_with_quant_row_offset.html" title="Matrix packed for the first input matrix in GEMM (usually activation), and row offsets used for requa...">PackAWithQuantRowOffset</a></td></tr>
    <tr><td class="paramname">packingBMatrix</td><td>processing of B matrix while packing, e.g., pre-multiply by alpha </td></tr>
    <tr><td class="paramname">cT</td><td>data type of C matrix </td></tr>
    <tr><td class="paramname">processOutputType</td><td>further processing of outputs, e.g., Relu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf9cb71c5c3a79935f7146f05510bb19" name="abf9cb71c5c3a79935f7146f05510bb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9cb71c5c3a79935f7146f05510bb19">&#9670;&#160;</a></span>fbgemmPartition1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbgemmPartition1D </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thread_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>total_work</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition work across given number of threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Given thread_id should execute starting from the index start </td></tr>
    <tr><td class="paramname">stop</td><td>Given thread_id should stop executing at the index stop</td></tr>
  </table>
  </dd>
</dl>
<p>i.e., the loop should be equivalent to for(int i = start; i &lt; end; ++i) </p>

</div>
</div>
<a id="ae6d6321b283eaa5a8ddaaa96ea22c62f" name="ae6d6321b283eaa5a8ddaaa96ea22c62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d6321b283eaa5a8ddaaa96ea22c62f">&#9670;&#160;</a></span>fbgemmPartition1DBlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbgemmPartition1DBlocked </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thread_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>total_work</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition work across given number of threads in blocks of size block_size. Each thread gets a multiple of block_size work or nothing, except the last one. The last one might receive the fringe case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Given thread_id should execute starting from the index start </td></tr>
    <tr><td class="paramname">stop</td><td>Given thread_id should stop executing at the index stop</td></tr>
  </table>
  </dd>
</dl>
<p>The loop can be equivalent to for(int i = start; i &lt; end; i+=block_size) except for the last thread. (i.e., thread_id = num_threads - 1)</p>
<p>Example 1: block_size = 2, num_threads = 2 total_work start(th 0) end(th 0) start(th 1) end(th 1) 4 0 2 2 4 5 0 2 2 5</p>
<p>Example 2: block_size = 2, num_threads = 3 total_work start(th 0) end(th 0) start(th 1) end(th 1) 4 0 2 2 4 5 0 2 2 4</p>
<p>total_work start(th 2) end(th 2) 4 4 4 5 4 5</p>
<p>Example 3: block_size = 2, num_threads = 4 total_work start(th 0) end(th 0) start(th 1) end(th 1) 4 0 2 2 4 5 0 2 2 4</p>
<p>total_work start(th 2) end(th 2) start(th 3) end(th 3) 4 4 4 4 4 5 4 4 4 5 </p>

</div>
</div>
<a id="afc22ec6e38a38c7f41484f844dbfbeac" name="afc22ec6e38a38c7f41484f844dbfbeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc22ec6e38a38c7f41484f844dbfbeac">&#9670;&#160;</a></span>Float16ToFloat_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Float16ToFloat_ref </td>
          <td>(</td>
          <td class="paramtype">const float16 *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ Transform all entries in a matrix from float16 to fp32: reference implementation. </p>

</div>
</div>
<a id="af066434e23720ecd4ddcc51d7a616aef" name="af066434e23720ecd4ddcc51d7a616aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af066434e23720ecd4ddcc51d7a616aef">&#9670;&#160;</a></span>Float16ToFloat_simd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Float16ToFloat_simd </td>
          <td>(</td>
          <td class="paramtype">const float16 *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ Transform all entries in a matrix from float16 to fp32: simd implementation. </p>

</div>
</div>
<a id="afafa94e239d016cf273ad0597152b86c" name="afafa94e239d016cf273ad0597152b86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafa94e239d016cf273ad0597152b86c">&#9670;&#160;</a></span>FloatOrHalfToFused8BitRowwiseQuantizedSBFloat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FloatOrHalfToFused8BitRowwiseQuantizedSBFloat </td>
          <td>(</td>
          <td class="paramtype">const InputType *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>input_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>input_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert float or half inputs to rowwise quantized (8-bit) outputs. Scale and Bias are in float. Each row's Scale and Bias are stored in the row itself (fused) at the end.</p>
<p>This version intentionally supports only 8-bit because we want to discourage the usage of float scale and bias with 2 and 4 bit cases as that diminishes the overall memory savings. </p>

</div>
</div>
<a id="a7cba6dad217715349653862b3e691057" name="a7cba6dad217715349653862b3e691057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cba6dad217715349653862b3e691057">&#9670;&#160;</a></span>FloatOrHalfToFused8BitRowwiseQuantizedSBFloatRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FloatOrHalfToFused8BitRowwiseQuantizedSBFloatRef </td>
          <td>(</td>
          <td class="paramtype">const InputType *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>input_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>input_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as FloatOrHalfToFused8BitRowwiseQuantizedSBFloat but unoptimized. This should not be called directly except in testing. </p>

</div>
</div>
<a id="ad89426896d5c7b1f1b5db8ebaf201547" name="ad89426896d5c7b1f1b5db8ebaf201547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89426896d5c7b1f1b5db8ebaf201547">&#9670;&#160;</a></span>FloatOrHalfToFusedNBitRowwiseQuantizedSBHalfRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FloatOrHalfToFusedNBitRowwiseQuantizedSBHalfRef </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bit_rate</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputType *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>input_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>input_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as ToFusedNBitRowwiseQuantizedSBHalf but unoptimized. This should not be called directly except in testing. </p>

</div>
</div>
<a id="ab22f5d961c6a42aab1c37b17a3d93770" name="ab22f5d961c6a42aab1c37b17a3d93770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22f5d961c6a42aab1c37b17a3d93770">&#9670;&#160;</a></span>FloatToBfloat16_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FloatToBfloat16_ref </td>
          <td>(</td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bfloat16 *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ Transform all entries in a matrix from fp32 to bfloat16: reference implementation. </p>

</div>
</div>
<a id="aa423a42208a4fde5f23ab6a28cef24a3" name="aa423a42208a4fde5f23ab6a28cef24a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa423a42208a4fde5f23ab6a28cef24a3">&#9670;&#160;</a></span>FloatToBfloat16_simd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FloatToBfloat16_simd </td>
          <td>(</td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bfloat16 *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ Transform all entries in a matrix from fp32 to bfloat16: simd implementation. </p>

</div>
</div>
<a id="af44c584c974f95f4866806cee3798742" name="af44c584c974f95f4866806cee3798742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44c584c974f95f4866806cee3798742">&#9670;&#160;</a></span>FloatToFloat16_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FloatToFloat16_ref </td>
          <td>(</td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float16 *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>do_clip</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ Transform all entries in a matrix from fp32 to float16: reference implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">do_clip</td><td>if true we saturate to fp16 min and max instead of generating infinities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53a50b113345c09b89b45834f31d52df" name="a53a50b113345c09b89b45834f31d52df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a50b113345c09b89b45834f31d52df">&#9670;&#160;</a></span>FloatToFloat16_simd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FloatToFloat16_simd </td>
          <td>(</td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float16 *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>do_clip</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ Transform all entries in a matrix from fp32 to float16: simd implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">do_clip</td><td>if true we saturate to fp16 min and max instead of generating infinities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42aefaaf238d065625a64a757f998eef" name="a42aefaaf238d065625a64a757f998eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42aefaaf238d065625a64a757f998eef">&#9670;&#160;</a></span>Fused8BitRowwiseQuantizedSBFloatToFloatOrHalf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Fused8BitRowwiseQuantizedSBFloatToFloatOrHalf </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>input_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>input_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert fused rowwise quantized (8-bit) inputs to float or half outputs. Scale and Bias are in float. Each row's Scale and Bias are stored in the row itself (fused) at the end.</p>
<p>This version intentionally supports only 8-bit because the corresponding quantize version only supports 8-bit. </p>

</div>
</div>
<a id="a19217d3a8551a7b251ecb1eba79669bc" name="a19217d3a8551a7b251ecb1eba79669bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19217d3a8551a7b251ecb1eba79669bc">&#9670;&#160;</a></span>Fused8BitRowwiseQuantizedSBFloatToFloatOrHalfRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Fused8BitRowwiseQuantizedSBFloatToFloatOrHalfRef </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>input_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>input_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as Fused8BitRowwiseQuantizedSBFloatToFloatOrHalf but unoptimized. This should not be called directly except in testing. </p>

</div>
</div>
<a id="a2b2ca55a7d2d5c2dbba337ee2e585f6a" name="a2b2ca55a7d2d5c2dbba337ee2e585f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2ca55a7d2d5c2dbba337ee2e585f6a">&#9670;&#160;</a></span>FusedNBitRowwiseQuantizedSBHalfToFloatOrHalf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FusedNBitRowwiseQuantizedSBHalfToFloatOrHalf </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bit_rate</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>input_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>input_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert fused rowwise quantized inputs to float (fp32 or fp16). bitrate specifies the number of bits in quantized input. Scale and Bias are in fp16. Each row's Scale and Bias are stored in the row itself (fused) at the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_rate</td><td>can be 2, 4, or 8 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adee65a9c68614b76ffdf2b3bc11b4618" name="adee65a9c68614b76ffdf2b3bc11b4618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee65a9c68614b76ffdf2b3bc11b4618">&#9670;&#160;</a></span>FusedNBitRowwiseQuantizedSBHalfToFloatOrHalfRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FusedNBitRowwiseQuantizedSBHalfToFloatOrHalfRef </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bit_rate</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>input_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>input_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as FusedNBitRowwiseQuantizedSBHalfToFloat but unoptimized. This should not be called directly except in testing. </p>

</div>
</div>
<a id="aa06c4dd5673e6b3df1dfe3617fdc919d" name="aa06c4dd5673e6b3df1dfe3617fdc919d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06c4dd5673e6b3df1dfe3617fdc919d">&#9670;&#160;</a></span>gen16BitVectorOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> instSet, typename T , typename std::enable_if&lt; instSet==inst_set_t::avx2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gen16BitVectorOne </td>
          <td>(</td>
          <td class="paramtype">x86::Emitter *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create instruction sequence to generate 16-bit 1s. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Register type of destination, e.g., x86::Ymm or x86::Zmm</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Once the instruction sequence is executed, dest[0:15] will have 0x0001, dest[16:31] will have 0x0001 and so on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c476c8ddbed58f3f6b4395dd55ed2a3" name="a3c476c8ddbed58f3f6b4395dd55ed2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c476c8ddbed58f3f6b4395dd55ed2a3">&#9670;&#160;</a></span>gen8BitVectorOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_same&lt; T, x86::Ymm &gt;::value, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gen8BitVectorOne </td>
          <td>(</td>
          <td class="paramtype">x86::Emitter *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create instruction sequence to generate 8-bit 1s. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Register type of destination, e.g., x86::Ymm or x86::Zmm</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Once the instruction sequence is executed, dest[0:7] will have 0x01, dest[8:15] will have 0x01 and so on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77602a69076f938d21d336a0df00f9c4" name="a77602a69076f938d21d336a0df00f9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77602a69076f938d21d336a0df00f9c4">&#9670;&#160;</a></span>GenerateEmbeddingSpMDM()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InType , typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float, bool THREAD_LOCAL = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmbeddingSpMDMKernelSignature&lt; InType, IndexType, OffsetType, OutType &gt;::Type GenerateEmbeddingSpMDM </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_weight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalize_by_lengths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prefetch</em><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_weight_positional</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_bf16_out</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_bf16_in</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InType</td><td>can be float, float16, or uint8_t </td></tr>
    <tr><td class="paramname">IndexType</td><td>can be int32_t or int64_t </td></tr>
    <tr><td class="paramname">IndexType</td><td>can be int32_t or int64_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_offsets</td><td>If true, the generated code assumes we will pass offsets instead of lengths that confirms PyTorch EmbeddingBag interface. In this case, the length of offsets array should be output_size + 1 and offsets[output_size] should be index_size. If false, the generate code assumes we will pass lengths that confirms Caffe2 SparseLengthsSum interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57534e5ede9766d50e536437b499894d" name="a57534e5ede9766d50e536437b499894d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57534e5ede9766d50e536437b499894d">&#9670;&#160;</a></span>GenerateEmbeddingSpMDMFP8WithStrides()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmbeddingSpMDMKernelSignature&lt; std::uint8_t, IndexType, OffsetType, OutType &gt;::Type GenerateEmbeddingSpMDMFP8WithStrides </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalize_by_lengths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_weight_positional</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>output_stride</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>input_stride</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>exponent_bits</em><span class="paramdefsep"> = </span><span class="paramdefval">4</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>exponent_bias</em><span class="paramdefsep"> = </span><span class="paramdefval">7</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_bf16_out</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_stride</td><td>If -1, output_stride is same as block_size </td></tr>
    <tr><td class="paramname">input_stride</td><td>in Bytes. If -1, input_stride is same as block_size / num_elem_per_byte + 2 * sizeof(float16) </td></tr>
    <tr><td class="paramname">exponent_bits</td><td>is the number of exponent bits in the FP8 encode (normally 4 or 5) </td></tr>
    <tr><td class="paramname">exponent_bias</td><td>is subtracted from the exponent to obtain the actual exponent for the floating-point number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4e2948ec5f9097f552de8a0458d49e1" name="aa4e2948ec5f9097f552de8a0458d49e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e2948ec5f9097f552de8a0458d49e1">&#9670;&#160;</a></span>GenerateEmbeddingSpMDMNBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmbeddingSpMDMKernelSignature&lt; std::uint8_t, IndexType, OffsetType, OutType &gt;::Type GenerateEmbeddingSpMDMNBit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bit_rate</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_weight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalize_by_lengths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prefetch</em><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_weight_positional</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>can be int32_t or int64_t </td></tr>
    <tr><td class="paramname">OffsetType</td><td>can be int32_t or int64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_rate</td><td>can be 2 or 4 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7d2220ddfc7d5c9820fd03b73101d37" name="aa7d2220ddfc7d5c9820fd03b73101d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d2220ddfc7d5c9820fd03b73101d37">&#9670;&#160;</a></span>GenerateEmbeddingSpMDMNBitRowWiseSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename OffsetType  = std::int32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmbeddingSpMDMRowWiseSparseKernelSignature&lt; std::uint8_t, IndexType, OffsetType &gt;::Type GenerateEmbeddingSpMDMNBitRowWiseSparse </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bit_rate</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_weight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalize_by_lengths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prefetch</em><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_weight_positional</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>can be int32_t or int64_t </td></tr>
    <tr><td class="paramname">OffsetType</td><td>can be int32_t or int64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_rate</td><td>can be 2 or 4 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb137866f8726f5c6cbf150ccc7e5b08" name="abb137866f8726f5c6cbf150ccc7e5b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb137866f8726f5c6cbf150ccc7e5b08">&#9670;&#160;</a></span>GenerateEmbeddingSpMDMNBitWithStrides()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float, bool THREAD_LOCAL = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmbeddingSpMDMKernelSignature&lt; std::uint8_t, IndexType, OffsetType, OutType &gt;::Type GenerateEmbeddingSpMDMNBitWithStrides </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bit_rate</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_weight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalize_by_lengths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prefetch</em><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_weight_positional</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>output_stride</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>input_stride</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scale_bias_last</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_bf16_out</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_stride</td><td>If -1, output_stride is same as block_size </td></tr>
    <tr><td class="paramname">input_stride</td><td>in Bytes. If -1, input_stride is same as block_size / num_elem_per_byte + 2 * sizeof(float16) </td></tr>
    <tr><td class="paramname">scale_bias_last</td><td>if false, scale and bias appear at the beginning of each row and are in fp16 for table batched embedding (TBE) in FBGEMM_GPU. If false, it can also take -1 indices (output from pruned embedding id mapping) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d6fe14c3ad83011adb500625ecbff01" name="a6d6fe14c3ad83011adb500625ecbff01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6fe14c3ad83011adb500625ecbff01">&#9670;&#160;</a></span>GenerateEmbeddingSpMDMRowWiseSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InType , typename IndexType , typename OffsetType  = std::int32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmbeddingSpMDMRowWiseSparseKernelSignature&lt; InType, IndexType, OffsetType &gt;::Type GenerateEmbeddingSpMDMRowWiseSparse </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_weight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalize_by_lengths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prefetch</em><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_weight_positional</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InType</td><td>can be float, float16, or uint8_t </td></tr>
    <tr><td class="paramname">IndexType</td><td>can be int32_t or int64_t </td></tr>
    <tr><td class="paramname">OffsetType</td><td>can be int32_t or int64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a243ed0e4df7bb7b6c08a930ee71a996b" name="a243ed0e4df7bb7b6c08a930ee71a996b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243ed0e4df7bb7b6c08a930ee71a996b">&#9670;&#160;</a></span>GenerateEmbeddingSpMDMWithStrides()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InType , typename IndexType , typename OffsetType  = std::int32_t, typename OutType  = float, bool THREAD_LOCAL = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmbeddingSpMDMKernelSignature&lt; InType, IndexType, OffsetType, OutType &gt;::Type GenerateEmbeddingSpMDMWithStrides </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_weight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalize_by_lengths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prefetch</em><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_weight_positional</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>output_stride</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>input_stride</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scale_bias_last</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>no_bag</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_bf16_out</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_bf16_in</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_stride</td><td>If -1, output_stride is same as block_size </td></tr>
    <tr><td class="paramname">input_stride</td><td>If -1, input_stride is same as block_size </td></tr>
    <tr><td class="paramname">scale_bias_last</td><td>if false, scale and bias appear at the beginning of each row and are in fp16 for table batched embedding (TBE) in FBGEMM_GPU. If false, it can also take -1 indices (output from pruned embedding id mapping) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90ceef30c1643dd1a87b1a0753b52e87" name="a90ceef30c1643dd1a87b1a0753b52e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ceef30c1643dd1a87b1a0753b52e87">&#9670;&#160;</a></span>GenerateRowWiseSparseAdaGradFused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename OffsetType  = std::int32_t, typename DataType  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RowWiseSparseAdaGradFusedSignature&lt; IndexType, OffsetType, DataType &gt;::Type GenerateRowWiseSparseAdaGradFused </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prefetch</em><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_stochastic_rounding</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>grad_stride</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grad_stride</td><td>If -1, grad_stride is same as block size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a15434be774f5beeb39e4fe225d6fb9" name="a2a15434be774f5beeb39e4fe225d6fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a15434be774f5beeb39e4fe225d6fb9">&#9670;&#160;</a></span>genU8I8S32FMA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> INST_SET, typename std::enable_if&lt; INST_SET==inst_set_t::avx2||INST_SET==inst_set_t::avx512, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void genU8I8S32FMA </td>
          <td>(</td>
          <td class="paramtype">x86::Emitter *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>aReg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>bReg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>cReg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>oneReg16Bit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>tmpReg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates instruction sequence to compute s32 += U8 * I8. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Register type of destination, e.g., x86::Ymm or x86::Zmm</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cReg</td><td>contains result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9ddfdb1cd3e41712844257212fcb050" name="aa9ddfdb1cd3e41712844257212fcb050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ddfdb1cd3e41712844257212fcb050">&#9670;&#160;</a></span>genU8Sum4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a637f4382ad9fa1da0795e05672b74301">inst_set_t</a> INST_SET, typename std::enable_if&lt; INST_SET==inst_set_t::avx2||INST_SET==inst_set_t::avx512, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void genU8Sum4 </td>
          <td>(</td>
          <td class="paramtype">x86::Emitter *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>dest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>oneReg16Bit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structfbgemm_1_1simd__info.html">simd_info</a>&lt; INST_SET &gt;::vec_reg_t</td>          <td class="paramname"><span class="paramname"><em>tmpReg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add 4 consecutive numbers of type uint8 and emit their sum as 32-bit numbers. i.e., dest[0:31] contains src[0:7] + src[8:15] + src[16:23] + src[24:31]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Register type of destination, e.g., x86::Ymm or x86::Zmm</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>contains result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3535bf91ff758b3bd13929bf9f211c90" name="a3535bf91ff758b3bd13929bf9f211c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3535bf91ff758b3bd13929bf9f211c90">&#9670;&#160;</a></span>genU8Sum8()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void genU8Sum8 </td>
          <td>(</td>
          <td class="paramtype">x86::Emitter *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>dest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>tmpReg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add 8 consecutive numbers of type uint8 and emit their sum as 16-bit numbers. i.e., dest[0:15] contains src[0:7] + src[8:15] + src[16:23] + src[24:31] src[32:39] + src[40:47] + src[48:55] + src[56:63]. </p>
<p>and</p>
<p>dest[64:79] contains src[64:71] + src[71:79] + src[80:87] + src[88:95] src[96:103] + src[104:111] + src[112:119] + src[120:127]</p>
<p>so on</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Register type of destination, e.g., x86::Ymm or x86::Zmm</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>contains result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a50b707287c0456d23e735846b144c0" name="a3a50b707287c0456d23e735846b144c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a50b707287c0456d23e735846b144c0">&#9670;&#160;</a></span>initCRegs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initCRegs </td>
          <td>(</td>
          <td class="paramtype">x86::Emitter *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rowRegs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>colRegs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate instructions for initializing the C registers to 0. </p>
<p>Generate instructions for initializing the C registers to 0 in 32-bit Accumulation kernel. </p>

</div>
</div>
<a id="a28c69d65ed666a9f46dc4763be70cdf6" name="a28c69d65ed666a9f46dc4763be70cdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c69d65ed666a9f46dc4763be70cdf6">&#9670;&#160;</a></span>PackA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PackA </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nrow</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncol</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>from</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ldim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Todo: make it fast with AVX2 transpose. </p>
<p>class that performs packing of matrix in row-major or col-major format into internal packed blocked-row major format </p>

</div>
</div>
<a id="adfee356e154f8b2f88c725885b1dbc11" name="adfee356e154f8b2f88c725885b1dbc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfee356e154f8b2f88c725885b1dbc11">&#9670;&#160;</a></span>printMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void printMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae28c9cc48e43e99cb778d60ba35c0fbf">matrix_op_t</a></td>          <td class="paramname"><span class="paramname"><em>op</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>inp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>R</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>ld</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging helper. </p>
<p>Print the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Transpose type of the matrix. </td></tr>
    <tr><td class="paramname">R</td><td>The height of the matrix. </td></tr>
    <tr><td class="paramname">C</td><td>The width of the matrix. </td></tr>
    <tr><td class="paramname">ld</td><td>The leading dimension of the matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The prefix string before printing the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3350c03dc2d62e8e434332d088f6a895" name="a3350c03dc2d62e8e434332d088f6a895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3350c03dc2d62e8e434332d088f6a895">&#9670;&#160;</a></span>Quantize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool LEGACY = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Quantize </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>result_precision</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>result_is_signed</em><span class="paramdefsep"> = </span><span class="paramdefval">std::is_signed&lt;T&gt;::value</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quantize src using zero_point and scale, clamp to the specified precision, and convert it to type T </p>

</div>
</div>
<a id="a798fea9136d48e1cd4c8a2926fb869ed" name="a798fea9136d48e1cd4c8a2926fb869ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798fea9136d48e1cd4c8a2926fb869ed">&#9670;&#160;</a></span>requantize_u8acc32_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void requantize_u8acc32_ref </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ld</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>inp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>C_multiplier</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>C_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>A_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>B_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>row_offsets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>col_offsets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>bias</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncols_per_quant_group</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fuse_relu</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference implementation of requantization step. float multiplier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bias</td><td>can be nullptr </td></tr>
    <tr><td class="paramname">ncols_per_quant_group</td><td>the number of columns share the same quantization parameter. ncols_per_quant_group == N : per-tensor quantization ncols_per_quant_group == N / groups : per-group quantization ncols_per_quant_group == 1 : per-channel quantization </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab87b23be5587e267db6ab7d2b97c6915" name="ab87b23be5587e267db6ab7d2b97c6915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87b23be5587e267db6ab7d2b97c6915">&#9670;&#160;</a></span>requantize_u8acc32_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void requantize_u8acc32_ref </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ld</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>inp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>C_multiplier</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>C_right_shift</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>C_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>A_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>B_zero_point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>row_offsets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>col_offsets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>bias</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fuse_relu</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference implementation of requantization step. int32 multiplier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bias</td><td>can be nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f972dca3254066120f58af5cf3b304c" name="a8f972dca3254066120f58af5cf3b304c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f972dca3254066120f58af5cf3b304c">&#9670;&#160;</a></span>rowOffsetBufferSizeGConv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SPATIAL_DIM = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int rowOffsetBufferSizeGConv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfbgemm_1_1conv__param__t.html">conv_param_t</a>&lt; SPATIAL_DIM &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>conv_param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Size of row offset buffer in number of elements needed for fbgemmGroupwiseConv </dd></dl>

</div>
</div>
<a id="a3bee8daea3756d030209a6815db314d9" name="a3bee8daea3756d030209a6815db314d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bee8daea3756d030209a6815db314d9">&#9670;&#160;</a></span>rowwise_sparse_adagrad_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int rowwise_sparse_adagrad_ref </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>param_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>w</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>h</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *</td>          <td class="paramname"><span class="paramname"><em>indices</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>epsilon</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>lr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>weight_decay</em><span class="paramdefsep"> = </span><span class="paramdefval">0.f</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>counter</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>counter_halflife</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>number of rows reading </td></tr>
    <tr><td class="paramname">block_size</td><td>number of parameters per rows </td></tr>
    <tr><td class="paramname">param_size</td><td>total number of parameters </td></tr>
    <tr><td class="paramname">w</td><td>input parameters </td></tr>
    <tr><td class="paramname">g</td><td>input gradients </td></tr>
    <tr><td class="paramname">h</td><td>input momentum </td></tr>
    <tr><td class="paramname">indices</td><td>indices of each row </td></tr>
    <tr><td class="paramname">counter</td><td>used for weight_decay adjusted for frequency. nullptr when frequency adjustment is not used. Ignored when weight_decay == 0 </td></tr>
    <tr><td class="paramname">counter_halflife</td><td>weight_decay is adjusted only after this number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f04df11e31dd656955d1bd1f8a7893d" name="a3f04df11e31dd656955d1bd1f8a7893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f04df11e31dd656955d1bd1f8a7893d">&#9670;&#160;</a></span>sparse_adagrad_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int sparse_adagrad_ref </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>param_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>w</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>h</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *</td>          <td class="paramname"><span class="paramname"><em>indices</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>epsilon</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>lr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>weight_decay</em><span class="paramdefsep"> = </span><span class="paramdefval">0.f</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>counter</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>counter_halflife</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>number of rows reading </td></tr>
    <tr><td class="paramname">block_size</td><td>number of parameters per rows </td></tr>
    <tr><td class="paramname">param_size</td><td>total number of parameters </td></tr>
    <tr><td class="paramname">w</td><td>input parameters </td></tr>
    <tr><td class="paramname">g</td><td>input gradients </td></tr>
    <tr><td class="paramname">h</td><td>input momentum </td></tr>
    <tr><td class="paramname">indices</td><td>indices of each row </td></tr>
    <tr><td class="paramname">counter</td><td>used for weight_decay adjusted for frequency. nullptr when frequency adjustment is not used. Ignored when weight_decay == 0 </td></tr>
    <tr><td class="paramname">counter_halflife</td><td>weight_decay is adjusted only after this number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1671cc912f6aa4bab678a0d255c8a690" name="a1671cc912f6aa4bab678a0d255c8a690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1671cc912f6aa4bab678a0d255c8a690">&#9670;&#160;</a></span>SparseDenseMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDenseMM </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>row_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>col_idx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>values</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ldb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ldc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>accum</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accum</td><td>Controls accumulation. 1 means we're accumulating to the C Matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>Note on matrix order and layout: Unlike other fbgemm functions that follow PyTorch convention where A matrix is activation (so in uint8_t for quantized FC/Conv or fp32) and B matrix is weight (so in int8_t for quantized FC/Conv or fp32), here A is weight matrix. This is because we mostly target sparsity in weights and for row-major layout it's more efficient to have A as a sparse matrix: for each non-zero of A at ith row and kth column, we can access kth row of B, whose elements are contiguous in memory. If B matrix was sparse, for each non-zero of B at kth row and jth column, we would've needed to access kth column of A, whose elements are not contiguous in memory with C/C++'s row-major layout. Alternatively, we can call this function as if we're computing C^T = B^T * A^T while maintaining PyTorch's convention that the lefthand side matrix B is activation. If B matrix is in column-major layout, we don't need to do an extra transposition. The C matrix will be output in column-major layout, so if we have a back-to-back Sparse-Dense matrix-matrix multiplications, B matrices of subsequent matrices will be already in column-major layout. Refer to SparseDenseMMFP32Benchmark.cc for an example. </p>

</div>
</div>
<a id="a4f19d1389f9e99cc0daded599b1f1fd4" name="a4f19d1389f9e99cc0daded599b1f1fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f19d1389f9e99cc0daded599b1f1fd4">&#9670;&#160;</a></span>spmdm_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmdm_ref </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>A</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lda</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfbgemm_1_1_compressed_sparse_column.html">CompressedSparseColumn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>accumulation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ldc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>groups</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference implementation of SPMDM (sparse matrix times dense matrix). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>when &gt; 1, for gth group, we multiply A[:,g*(A.ncols/groups):(g+1)*(A.ncols/groups)] sub-matrix with B[:,g*(B.ncols/groups):(g+1)*(B.ncols/groups)] sub-matrix . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18832d0507cb6d8bce78371b97f66479" name="a18832d0507cb6d8bce78371b97f66479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18832d0507cb6d8bce78371b97f66479">&#9670;&#160;</a></span>transpose_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transpose_ref </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ld_src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ld_dst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference implementation of matrix transposition: B = A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The height of the matrix. </td></tr>
    <tr><td class="paramname">N</td><td>The width of the matrix. </td></tr>
    <tr><td class="paramname">src</td><td>The memory buffer of the source matrix A. </td></tr>
    <tr><td class="paramname">ld_src</td><td>The leading dimension of the source matrix A. </td></tr>
    <tr><td class="paramname">dst</td><td>The memory buffer of the destination matrix B. </td></tr>
    <tr><td class="paramname">ld_dst</td><td>The leading dimension of the destination matrix B. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75b4ad78ae16c6e6782f82e1ff4012a8" name="a75b4ad78ae16c6e6782f82e1ff4012a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b4ad78ae16c6e6782f82e1ff4012a8">&#9670;&#160;</a></span>transpose_simd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transpose_simd </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ld_src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ld_dst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the number of rows of input matrix </td></tr>
    <tr><td class="paramname">N</td><td>the number of columns of input matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
